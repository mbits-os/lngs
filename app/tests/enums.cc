#include <gtest/gtest.h>
#include <lngs/internals/commands.hpp>
#include <lngs/internals/strings.hpp>
#include "diag_helper.h"
#include "test_env.hh"

namespace lngs::app::testing {
	using namespace ::std::literals;
	using ::testing::TestWithParam;
	using ::testing::ValuesIn;

	struct enums_result {
		std::string_view title;
		std::string_view input;
		std::string output;
		std::string output_with_res;
	};

	std::ostream& operator<<(std::ostream& out, enums_result const& result) {
		return out << result.title;
	}

	class enums : public TestWithParam<enums_result> {};

	TEST_P(enums, text) {
		auto [title, input, expected, with_resource] = GetParam();

		diags::sources diag;
		diag.set_contents("", input);

		test_env<outstrstream> data{};
		bool idl_valid = read_strings(diag.source(""), data.strings, diag);
		EXPECT_TRUE(idl_valid);

		app::enums::write(data.env(), false);
		EXPECT_EQ(expected, data.output.contents);
	}

	TEST_P(enums, text_res) {
		auto [title, input, expected, with_resource] = GetParam();

		diags::sources diag;
		diag.set_contents("", input);

		test_env<outstrstream> data{};
		bool idl_valid = read_strings(diag.source(""), data.strings, diag);
		EXPECT_TRUE(idl_valid);

		app::enums::write(data.env(), true);
		EXPECT_EQ(with_resource, data.output.contents);
	}

	const enums_result sources[] = {
	    {"plural/noname",
	     R"([serial(0)]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
	[id(-1), help("help string")] ID3 = "value3";
})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace  {
    enum class lng {
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    using Strings = lngs::StringsWithPlurals<lng, counted, lngs::VersionedFile<0>>;
} // namespace 
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace  {
    enum class lng {
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::StringsWithPlurals<lng, counted, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace 
// clang-format on
)"},
	    {"plural/with name",
	     R"([serial(0), project("name")]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
	[id(-1), help("help string")] ID3 = "value3";
})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class lng {
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    using Strings = lngs::StringsWithPlurals<lng, counted, lngs::VersionedFile<0>>;
} // namespace name
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class lng {
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::StringsWithPlurals<lng, counted, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace name
// clang-format on
)"},
	    {"plural/with name+serial",
	     R"([serial(1250), project("name")]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
	[id(-1), help("help string")] ID3 = "value3";
})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class lng {
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    using Strings = lngs::StringsWithPlurals<lng, counted, lngs::VersionedFile<1250>>;
} // namespace name
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class lng {
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::StringsWithPlurals<lng, counted, lngs::VersionedFile<1250,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace name
// clang-format on
)"},
	    {"singular",
	     R"([serial(0), project("name")]
strings {
	[id(1001), help("help string")] ID = "value";
	[id(1002), help("help string")] ID2 = "value2";
	[id(1003), help("help string")] ID3 = "value3";
})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class lng {
        /// value (help string)
        ID = 1001,
        /// value2 (help string)
        ID2 = 1002,
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    using Strings = lngs::SingularStrings<lng, lngs::VersionedFile<0>>;
} // namespace name
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class lng {
        /// value (help string)
        ID = 1001,
        /// value2 (help string)
        ID2 = 1002,
        /// value3 (help string)
        ID3 = 1003,
    }; // enum class lng

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<lng, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace name
// clang-format on
)"},
	    {"plural/not frozen",
	     R"([serial(0), project("name")]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    using Strings = lngs::PluralOnlyStrings<counted, lngs::VersionedFile<0>>;
} // namespace name
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class counted {
        /// value | values (help string)
        ID = 1002,
        /// value2 | values (help string)
        ID2 = 1001,
    }; // enum class counted

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::PluralOnlyStrings<counted, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace name
// clang-format on
)"},
	    {"empty", R"([serial(0), project("name")] strings {})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class faulty {
        UNDEFINED = 0 // File did not define any strings
    }; // enum class faulty

    using Strings = lngs::SingularStrings<faulty, lngs::VersionedFile<0>>;
} // namespace name
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name {
    enum class faulty {
        UNDEFINED = 0 // File did not define any strings
    }; // enum class faulty

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<faulty, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace name
// clang-format on
)"},
	    {"empty/namespace",
	     R"([serial(0), project("name::sub"), namespace("something::else")] strings {})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace something::else {
    enum class faulty {
        UNDEFINED = 0 // File did not define any strings
    }; // enum class faulty

    using Strings = lngs::SingularStrings<faulty, lngs::VersionedFile<0>>;
} // namespace something::else
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace something::else {
    enum class faulty {
        UNDEFINED = 0 // File did not define any strings
    }; // enum class faulty

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<faulty, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace something::else
// clang-format on
)"},
	    {"empty/::", R"([serial(0), project("name::sub")] strings {})",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name::sub {
    enum class faulty {
        UNDEFINED = 0 // File did not define any strings
    }; // enum class faulty

    using Strings = lngs::SingularStrings<faulty, lngs::VersionedFile<0>>;
} // namespace name::sub
// clang-format on
)",
	     R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

// clang-format off
namespace name::sub {
    enum class faulty {
        UNDEFINED = 0 // File did not define any strings
    }; // enum class faulty

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<faulty, lngs::VersionedFile<0,
        lngs::storage::FileWithBuiltin<Resource>>>;
} // namespace name::sub
// clang-format on
)"},
	};

	INSTANTIATE_TEST_SUITE_P(sources, enums, ValuesIn(sources));
}  // namespace lngs::app::testing
