#include <gtest/gtest.h>
#include "diag_helper.h"
#include <lngs/internals/commands.hpp>
#include <lngs/internals/strings.hpp>

namespace lngs::app::testing {
	using namespace ::std::literals;
	using ::testing::TestWithParam;
	using ::testing::ValuesIn;

	struct enums_result {
		std::string_view input;
		std::string output;
		std::string output_with_res;
	};

	class enums : public TestWithParam<enums_result> {};

	TEST_P(enums, text) {
		auto[input, expected, with_resource] = GetParam();

		diagnostics diag;
		diag.set_contents("", input);

		idl_strings strings;
		bool idl_valid = read_strings(diag.source(""), strings, diag);
		EXPECT_TRUE(idl_valid);

		{
			outstrstream output;
			app::enums::write(output, strings, false);
			EXPECT_EQ(expected, output.contents);
		}

		{
			outstrstream output;
			app::enums::write(output, strings, true);
			EXPECT_EQ(with_resource, output.contents);
		}
	}

	const enums_result sources[] = {
		{
			R"([serial(0)]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
	[id(-1), help("help string")] ID3 = "value3";
})",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace  {
    enum class lng {
        ID3 = 1003, // value3 (help string)
    }; // enum class lng

    enum class lngs {
        ID = 1002, // value | values (help string)
        ID2 = 1001, // value2 | values (help string)
    }; // enum class lngs

    using Strings = lngs::StringsWithPlurals<lng, lngs>;
}; // namespace 
)",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace  {
    enum class lng {
        ID3 = 1003, // value3 (help string)
    }; // enum class lng

    enum class lngs {
        ID = 1002, // value | values (help string)
        ID2 = 1001, // value2 | values (help string)
    }; // enum class lngs

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::StringsWithPlurals<lng, lngs, lngs::storage::FileWithBuiltin<Resource>>;
}; // namespace 
)"
		},
		{
			R"([serial(0), project("name")]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
	[id(-1), help("help string")] ID3 = "value3";
})",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class lng {
        ID3 = 1003, // value3 (help string)
    }; // enum class lng

    enum class lngs {
        ID = 1002, // value | values (help string)
        ID2 = 1001, // value2 | values (help string)
    }; // enum class lngs

    using Strings = lngs::StringsWithPlurals<lng, lngs>;
}; // namespace name
)",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class lng {
        ID3 = 1003, // value3 (help string)
    }; // enum class lng

    enum class lngs {
        ID = 1002, // value | values (help string)
        ID2 = 1001, // value2 | values (help string)
    }; // enum class lngs

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::StringsWithPlurals<lng, lngs, lngs::storage::FileWithBuiltin<Resource>>;
}; // namespace name
)"
		},
		{
			R"([serial(0), project("name")]
strings {
	[id(1001), help("help string")] ID = "value";
	[id(1002), help("help string")] ID2 = "value2";
	[id(1003), help("help string")] ID3 = "value3";
})",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class lng {
        ID = 1001, // value (help string)
        ID2 = 1002, // value2 (help string)
        ID3 = 1003, // value3 (help string)
    }; // enum class lng

    using Strings = lngs::SingularStrings<lng>;
}; // namespace name
)",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class lng {
        ID = 1001, // value (help string)
        ID2 = 1002, // value2 (help string)
        ID3 = 1003, // value3 (help string)
    }; // enum class lng

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<lng, lngs::storage::FileWithBuiltin<Resource>>;
}; // namespace name
)"
		},
		{
			R"([serial(0), project("name")]
strings {
	[id(-1), help("help string"), plural("values")] ID = "value";
	[id(1001), plural("values"), help("help string")] ID2 = "value2";
})",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class lngs {
        ID = 1002, // value | values (help string)
        ID2 = 1001, // value2 | values (help string)
    }; // enum class lngs

    using Strings = lngs::PluralOnlyStrings<lngs>;
}; // namespace name
)",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class lngs {
        ID = 1002, // value | values (help string)
        ID2 = 1001, // value2 | values (help string)
    }; // enum class lngs

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::PluralOnlyStrings<lngs, lngs::storage::FileWithBuiltin<Resource>>;
}; // namespace name
)"
		},
		{
			R"([serial(0), project("name")] strings {})",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class faulty {
        UNDEFINED = 0 // File did not define any string
    }; // enum class faulty

    using Strings = lngs::SingularStrings<faulty>;
}; // namespace name
)",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name {
    enum class faulty {
        UNDEFINED = 0 // File did not define any string
    }; // enum class faulty

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<faulty, lngs::storage::FileWithBuiltin<Resource>>;
}; // namespace name
)"
		},
		{
			R"([serial(0), project("name::sub")] strings {})",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name::sub {
    enum class faulty {
        UNDEFINED = 0 // File did not define any string
    }; // enum class faulty

    using Strings = lngs::SingularStrings<faulty>;
}; // namespace name::sub
)",
			R"(// THIS FILE IS AUTOGENERATED
#pragma once

#include <lngs/lngs.hpp>

namespace name::sub {
    enum class faulty {
        UNDEFINED = 0 // File did not define any string
    }; // enum class faulty

    struct Resource {
        static const char* data();
        static std::size_t size();
    };

    using Strings = lngs::SingularStrings<faulty, lngs::storage::FileWithBuiltin<Resource>>;
}; // namespace name::sub
)"
		},
	};

	INSTANTIATE_TEST_SUITE_P(sources, enums, ValuesIn(sources));
}
