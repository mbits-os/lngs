/*
 * Copyright (C) 2015 midnightBITS
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <lngs/commands.hpp>
#include <lngs/strings.hpp>
#include <lngs/streams.hpp>
#include <lngs/languages.hpp>

namespace lngs::res {
	class table_outstream : public outstream {
		static constexpr size_t row_width = 16;
		outstream& parent;
		size_t offset = 0;
		bool new_string = true;
		bool seen_strings = false;
		bool header_printed = false;
	public:
		table_outstream(outstream& parent)
			: parent(parent)
		{
		}
		std::size_t write(const void* data, std::size_t length) noexcept override;
		bool finalize();
	};

	std::size_t table_outstream::write(const void* data, std::size_t length) noexcept
	{
		auto chars = reinterpret_cast<const uint8_t*>(data);
		auto save = offset;

		for (size_t i = 0; i < length; ++i, ++offset, ++chars) {
			if ((offset % row_width) == 0) {
				constexpr const char prefix[] = "            \"";
				if (parent.fmt(prefix) != sizeof(prefix) - 1)
					break;
			}
			if (parent.fmt("\\x{:02x}", *chars) != 4)
				break;
			if (((offset + 1) % row_width) == 0) {
				if (parent.fmt("\"\n") != 2)
					break;
			}
		}

		return offset - save;
	}

	bool table_outstream::finalize()
	{
		if ((offset % row_width) != 0)
			return parent.fmt("\"\n") == 2;
		return true;
	}

	file make_resource(const idl_strings& defs, bool warp_strings, bool with_keys) {
		file file;
		file.serial = defs.serial;

		file.strings.reserve(defs.strings.size());
		if (with_keys)
			file.keys.reserve(defs.strings.size());

		bool has_plurals = false;
		for (auto& string : defs.strings) {
			if (!string.plural.empty())
				has_plurals = true;
			auto value = string.value;
			if (warp_strings)
				value = warp(value);

			if (!string.plural.empty()) {
				value.push_back(0);
				if (warp_strings)
					value.append(warp(string.plural));
				else
					value.append(string.plural);
			}

			if (with_keys)
				file.keys.emplace_back(string.id, string.key);
			file.strings.emplace_back(string.id, value);
		}
		if (has_plurals)
			file.attrs.emplace_back(locale::ATTR_PLURALS, "nplurals=2; plural=(n != 1);");
		return file;
	}

	int update_and_write(outstream& out, file& data, std::string_view include, std::string_view project) {
		out.fmt(R"(// THIS FILE IS AUTOGENERATED
#include "{0}"

namespace {1} {{
    namespace {{
        const char __resource[] = {{
)", include, project);

		{
			table_outstream os{ out };
			auto ret = data.write(os);
			if (ret)
				return ret;
			if (!os.finalize())
				return -1;
		}

		out.fmt(R"(        }}; // __resource
    }} // namespace

    /*static*/ const char* Resource::data() {{ return __resource; }}
    /*static*/ std::size_t Resource::size() {{ return sizeof(__resource); }}
}} // namespace {}
)", project);
		return 0;
	}
}
