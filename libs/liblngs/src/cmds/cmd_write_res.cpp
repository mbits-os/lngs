/*
 * Copyright (C) 2015 midnightBITS
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <locale/file.hpp>
#include <lngs/argparser.hpp>
#include <lngs/strings.hpp>
#include <lngs/streams.hpp>
#include <lngs/languages.hpp>

namespace res {
	class table_outstream : public locale::outstream {
		static constexpr size_t row_width = 16;
		std::FILE* ptr;
		size_t offset = 0;
		bool new_string = true;
		bool seen_strings = false;
		bool header_printed = false;
	public:
		table_outstream(std::FILE* ptr)
			: ptr(ptr)
		{
		}
		std::size_t write(const void* data, std::size_t length) override;
		void finalize();
	};

	std::size_t table_outstream::write(const void* data, std::size_t length)
	{
		auto chars = reinterpret_cast<const char*>(data);
		auto save = offset;

		for (size_t i = 0; i < length; ++i, ++offset, ++chars) {
			if ((offset % row_width) == 0)
				fprintf(ptr, "            \"");
			fprintf(ptr, "\\x%02x", (uint8_t)*chars);
			if (((offset + 1) % row_width) == 0)
				fprintf(ptr, "\"\n");
		}

		return offset - save;
	}

	void table_outstream::finalize()
	{
		if ((offset % row_width) != 0)
			fprintf(ptr, "\"\n");
	}

	int call(args::parser& parser)
	{
		fs::path inname, outname;
		bool verbose = false;
		bool warp_strings = false;
		bool with_keys = false;
		std::string include;

		parser.set<std::true_type>(verbose, "v", "verbose").help("show more info").opt();
		parser.set<std::true_type>(warp_strings, "w", "warp").help("replace all strings with warped ones; plural strings will still be plural (as if English)").opt();
		parser.set<std::true_type>(with_keys, "k", "keys").help("add string block with string keys").opt();
		parser.arg(outname, "o", "out").meta("FILE").help("LNG binary file to write; if - is used, result is written to standard output");
		parser.arg(inname, "i", "in").meta("FILE").help("LNGS message file to read");
		parser.arg(include, "include").meta("FILE").help("File to include for the definition of the Resource class. Defaults to \"<project>.hpp\".").opt();
		parser.parse();

		locale::Strings strings;
		if (!locale::read_strings(inname, strings, verbose))
			return -1;

		if (include.empty())
			include = strings.project + ".hpp";

		locale::file file;
		for (auto& string : strings.strings) {
			auto value = string.value;
			if (warp_strings)
				value = locale::warp(value);

			if (!string.plural.empty()) {
				value.push_back(0);
				if (warp_strings)
					value.append(locale::warp(string.plural));
				else
					value.append(string.plural);
			}

			if (with_keys)
				file.keys.emplace_back(string.id, string.key);
			file.strings.emplace_back(string.id, value);
		}
		file.attrs.emplace_back(locale::attr_t::ATTR_PLURALS, "nplurals=2; plural=(n != 1);");

		fs::file outf;
		FILE* output = stdout;
		if (outname != "-") {
			outf = fs::fopen(outname, "w");
			if (!outf) {
				fprintf(stderr, "could not open `%s'", outname.string().c_str());
				return -1;
			}

			if (verbose)
				printf("%s\n", outname.string().c_str());

			output = outf.handle();
		}

		fprintf(output, R"(// THIS FILE IS AUTOGENERATED
#include "%s"

inline namespace %s {
    namespace {
        const char __resource[] = {
)", include.c_str(), strings.project.c_str());

		{
			table_outstream os{ output };
			//locale::memoutstream os;
			auto ret = file.write(os);
			if (ret)
				return ret;
			os.finalize();
		}

		fprintf(output, R"(        }; // __resource
    } // namespace

    /*static*/ const char* Resource::data() { return __resource; }
    /*static*/ std::size_t Resource::size() { return sizeof(__resource); }
} // namespace %s
)", strings.project.c_str());
		return 0;
	}
}
